---
layout: post
title: "类的安全性"
date: 2016-08-19 09:42:00
categories: 读书
---

##  类的安全性
    前面已经讲述了安全性的基本策略：synchronized和volatile；那么结合软件工程的原则，肯定需要封装这么相对复杂的东西，来对外界提供较为便捷
的使用方式。怎么封装呢？主要是利用synchronized
1.如果新写一个类，就需要将类的所有有冲突的并发访问通过synchronized控制
2.如果通过扩展现有类，则必须注意新添加的操作必须和旧有操作使用共同的锁，可以通过继承或者单纯客户端使用加锁的方式进行，更为健壮的方式是
像Collections.synchronizedList那样，将类完全封装，并具有和被封装类同样的接口，然后再扩展，同时使用自己的锁，而不管被包装类是否线程安全。

如果一个类的同步方法经过复合操作形成一个新的方法，新的方法也是要上锁的。

java提供了同步容器类，但基于同步容器类的复合操作（迭代、跳转（从当前元素跳转到下一个元素）、条件检查（若没有则添加）），在多线程环境下的执行，也是会
出现并发问题的，一般是使用内部的锁封装复合操作，或者，退一步讲，复制容器，在新的副本上操作。

   同步容器类由于独占式访问，肯定会影响性能，为了优化性能，java提供了并发容器类，优化性能？怎么优化呢，
策略1, 需要独占式访问，无非是减少竞争的几率，减少占用的时间,一般就是多个锁，减少同步代码块，典型的就是concurrentHashMap。
策略2, 不再独占式访问，而是克隆副本，不产生竞争，典型的是CopyOnWriteArrayList.
另外一个特殊的模式需要提一下，阻塞队列，生产者消费者模式的实现

最后，死锁的出现一般是由于程序中出现获得锁的顺序不一致导致